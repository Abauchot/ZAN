<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Inputs/GameInputs.asmdef">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Inputs/GameInputs.asmdef" />
              <option name="updatedContent" value="{&#13;&#10;  &quot;name&quot;: &quot;GameInputs&quot;,&#13;&#10;  &quot;rootNamespace&quot;: &quot;&quot;,&#13;&#10;  &quot;references&quot;: [],&#13;&#10;  &quot;includePlatforms&quot;: [],&#13;&#10;  &quot;excludePlatforms&quot;: [],&#13;&#10;  &quot;allowUnsafeCode&quot;: false,&#13;&#10;  &quot;overrideReferences&quot;: false,&#13;&#10;  &quot;precompiledReferences&quot;: [],&#13;&#10;  &quot;autoReferenced&quot;: true,&#13;&#10;  &quot;defineConstraints&quot;: [],&#13;&#10;  &quot;versionDefines&quot;: [],&#13;&#10;  &quot;noEngineReferences&quot;: false,&#13;&#10;  &quot;optionalUnityReferences&quot;: [&#13;&#10;    &quot;Unity.InputSystem&quot;&#13;&#10;  ]&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/GameScripts.asmdef">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/GameScripts.asmdef" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;GameScripts&quot;,&#10;  &quot;rootNamespace&quot;: &quot;&quot;,&#10;  &quot;references&quot;: [&#10;    &quot;GameInputs&quot;&#10;  ],&#10;  &quot;includePlatforms&quot;: [],&#10;  &quot;excludePlatforms&quot;: [],&#10;  &quot;allowUnsafeCode&quot;: false,&#10;  &quot;overrideReferences&quot;: false,&#10;  &quot;precompiledReferences&quot;: [],&#10;  &quot;autoReferenced&quot;: true,&#10;  &quot;defineConstraints&quot;: [],&#10;  &quot;versionDefines&quot;: [],&#10;  &quot;noEngineReferences&quot;: false,&#10;  &quot;optionalUnityReferences&quot;: [&#10;    &quot;Unity.InputSystem&quot;&#10;  ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Tests/DuelLogicTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Tests/DuelLogicTests.cs" />
              <option name="originalContent" value="using NUnit.Framework;&#10;using UnityEngine;&#10;&#10;[TestFixture]&#10;public class DuelLogicTests&#10;{&#10;    private DuelLogic _duelLogic;&#10;    private const int TestSeed = 12345; // Seed fixe pour des tests reproductibles&#10;&#10;    [SetUp]&#10;    public void SetUp()&#10;    {&#10;        _duelLogic = new DuelLogic(TestSeed);&#10;        _duelLogic.WaitRange = new Vector2(2f, 5f);&#10;        _duelLogic.ReactRange = new Vector2(100f, 200f);&#10;        _duelLogic.AiFalseStartChance = 0.05f;&#10;    }&#10;&#10;    [Test]&#10;    public void InitialState_ShouldBeReady()&#10;    {&#10;        // Arrange &amp; Act&#10;        var result = _duelLogic.UpdateState(0f, false);&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;        Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;        Assert.AreEqual(&quot;Press any key when ready&quot;, result.HintText);&#10;    }&#10;&#10;    [Test]&#10;    public void PressingInReadyState_ShouldTransitionToWaiting()&#10;    {&#10;        // Arrange&#10;        float currentTime = 0f;&#10;        &#10;        // Act&#10;        var result = _duelLogic.UpdateState(currentTime, true);&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Waiting, _duelLogic.State);&#10;        Assert.AreEqual(&quot;READY ?&quot;, result.StateText);&#10;        Assert.AreEqual(&quot;Wait ....&quot;, result.HintText);&#10;        Assert.Greater(_duelLogic.SignalAt, currentTime);&#10;    }&#10;&#10;    [Test]&#10;    public void PressingDuringWaiting_ShouldCauseFalseStart()&#10;    {&#10;        // Arrange&#10;        float currentTime = 0f;&#10;        _duelLogic.UpdateState(currentTime, true); // Transition to Waiting&#10;        &#10;        // Act&#10;        var result = _duelLogic.UpdateState(currentTime + 1f, true); // Press during waiting&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;        Assert.AreEqual(2, _duelLogic.Winner); // AI wins&#10;        Assert.AreEqual(&quot;FALSE START !&quot;, result.StateText);&#10;    }&#10;&#10;    [Test]&#10;    public void WaitingUntilSignal_ShouldTransitionToSignalState()&#10;    {&#10;        // Arrange&#10;        float currentTime = 0f;&#10;        _duelLogic.UpdateState(currentTime, true); // Transition to Waiting&#10;        float signalTime = _duelLogic.SignalAt;&#10;        &#10;        // Act&#10;        var result = _duelLogic.UpdateState(signalTime, false);&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Signal, _duelLogic.State);&#10;        Assert.AreEqual(&quot;GO !&quot;, result.StateText);&#10;        Assert.AreEqual(&quot;Press Now !&quot;, result.HintText);&#10;    }&#10;&#10;    [Test]&#10;    public void PressingAfterSignal_ShouldCalculateReactionTime()&#10;    {&#10;        // Arrange&#10;        float currentTime = 0f;&#10;        _duelLogic.UpdateState(currentTime, true); // Transition to Waiting&#10;        float signalTime = _duelLogic.SignalAt;&#10;        _duelLogic.UpdateState(signalTime, false); // Transition to Signal&#10;        &#10;        // Act&#10;        float reactionTime = signalTime + 0.15f; // 150ms reaction&#10;        var result = _duelLogic.UpdateState(reactionTime, true);&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;        Assert.AreEqual(1, _duelLogic.Winner); // Player wins&#10;        Assert.AreEqual(&quot;CALCULATING...&quot;, result.StateText);&#10;        Assert.AreEqual(&quot;150 ms&quot;, result.MsText);&#10;    }&#10;&#10;    [Test]&#10;    public void ResolveState_ShouldEventuallyTransitionToResults()&#10;    {&#10;        // Arrange&#10;        float currentTime = 0f;&#10;        _duelLogic.UpdateState(currentTime, true); // Ready -&gt; Waiting&#10;        float signalTime = _duelLogic.SignalAt;&#10;        _duelLogic.UpdateState(signalTime, false); // Waiting -&gt; Signal&#10;        _duelLogic.UpdateState(signalTime + 0.1f, true); // Signal -&gt; Resolve&#10;        &#10;        // Act - Wait for resolve timer&#10;        var result = _duelLogic.UpdateState(signalTime + 2f, false);&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Results, _duelLogic.State);&#10;        Assert.AreEqual(&quot;PLAYER WINS !&quot;, result.StateText);&#10;        Assert.AreEqual(&quot;Congratulations!&quot;, result.HintText);&#10;    }&#10;&#10;    [Test]&#10;    public void ResultsState_ShouldEventuallyResetToReady()&#10;    {&#10;        // Arrange - Get to Results state&#10;        float currentTime = 0f;&#10;        _duelLogic.UpdateState(currentTime, true); // Ready -&gt; Waiting&#10;        float signalTime = _duelLogic.SignalAt;&#10;        _duelLogic.UpdateState(signalTime, false); // Waiting -&gt; Signal&#10;        _duelLogic.UpdateState(signalTime + 0.1f, true); // Signal -&gt; Resolve&#10;        _duelLogic.UpdateState(signalTime + 2f, false); // Resolve -&gt; Results&#10;        &#10;        // Act - Wait for results timer&#10;        var result = _duelLogic.UpdateState(signalTime + 5f, false);&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;        Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;        Assert.AreEqual(&quot;Press any key when ready&quot;, result.HintText);&#10;        Assert.AreEqual(&quot;&quot;, result.MsText);&#10;    }&#10;&#10;    [Test]&#10;    public void StartRound_ShouldResetAllState()&#10;    {&#10;        // Arrange - Get to some advanced state&#10;        _duelLogic.UpdateState(0f, true);&#10;        &#10;        // Act&#10;        _duelLogic.StartRound();&#10;        &#10;        // Assert&#10;        Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;        Assert.AreEqual(0, _duelLogic.Winner);&#10;        Assert.IsFalse(_duelLogic.WinnerLocked);&#10;        Assert.AreEqual(0f, _duelLogic.SignalAt);&#10;        Assert.AreEqual(0f, _duelLogic.ReactedAt);&#10;    }&#10;&#10;    [Test]&#10;    public void ConfigurationProperties_ShouldAffectBehavior()&#10;    {&#10;        // Arrange&#10;        _duelLogic.WaitRange = new Vector2(1f, 1.1f); // Very short wait&#10;        _duelLogic.ReactRange = new Vector2(50f, 60f); // Fast AI reaction&#10;        &#10;        // Act&#10;        _duelLogic.UpdateState(0f, true); // Start waiting&#10;        float signalTime = _duelLogic.SignalAt;&#10;        &#10;        // Assert&#10;        Assert.GreaterOrEqual(signalTime, 1f);&#10;        Assert.LessOrEqual(signalTime, 1.1f);&#10;    }&#10;&#10;    [Test]&#10;    public void WinnerLocking_ShouldPreventStateChanges()&#10;    {&#10;        // Arrange - Get to resolve state&#10;        float currentTime = 0f;&#10;        _duelLogic.UpdateState(currentTime, true);&#10;        float signalTime = _duelLogic.SignalAt;&#10;        _duelLogic.UpdateState(signalTime, false);&#10;        _duelLogic.UpdateState(signalTime + 0.1f, true);&#10;        &#10;        // Act - Multiple updates in resolve state&#10;        _duelLogic.UpdateState(signalTime + 0.5f, false);&#10;        int firstWinner = _duelLogic.Winner;&#10;        _duelLogic.UpdateState(signalTime + 0.6f, false);&#10;        int secondWinner = _duelLogic.Winner;&#10;        &#10;        // Assert&#10;        Assert.IsTrue(_duelLogic.WinnerLocked);&#10;        Assert.AreEqual(firstWinner, secondWinner);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using NUnit.Framework;&#10;using UnityEngine;&#10;using Assert = NUnit.Framework.Assert;&#10;&#10;namespace Tests&#10;{&#10;    [TestFixture]&#10;    public class DuelLogicTests&#10;    {&#10;        private DuelLogic _duelLogic;&#10;        private const int TestSeed = 12345; // Seed fixe pour des tests reproductibles&#10;&#10;        [SetUp]&#10;        public void SetUp()&#10;        {&#10;            _duelLogic = new DuelLogic(TestSeed);&#10;            _duelLogic.WaitRange = new Vector2(2f, 5f);&#10;            _duelLogic.ReactRange = new Vector2(100f, 200f);&#10;            _duelLogic.AiFalseStartChance = 0.05f;&#10;        }&#10;&#10;        [Test]&#10;        public void InitialState_ShouldBeReady()&#10;        {&#10;            // Arrange &amp; Act&#10;            var result = _duelLogic.UpdateState(0f, false);&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;            Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;            Assert.AreEqual(&quot;Press any key when ready&quot;, result.HintText);&#10;        }&#10;&#10;        [Test]&#10;        public void PressingInReadyState_ShouldTransitionToWaiting()&#10;        {&#10;            // Arrange&#10;            float currentTime = 0f;&#10;            &#10;            // Act&#10;            var result = _duelLogic.UpdateState(currentTime, true);&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Waiting, _duelLogic.State);&#10;            Assert.AreEqual(&quot;READY ?&quot;, result.StateText);&#10;            Assert.AreEqual(&quot;Wait ....&quot;, result.HintText);&#10;            Assert.Greater(_duelLogic.SignalAt, currentTime);&#10;        }&#10;&#10;        [Test]&#10;        public void PressingDuringWaiting_ShouldCauseFalseStart()&#10;        {&#10;            // Arrange&#10;            float currentTime = 0f;&#10;            _duelLogic.UpdateState(currentTime, true); // Transition to Waiting&#10;            &#10;            // Act&#10;            var result = _duelLogic.UpdateState(currentTime + 1f, true); // Press during waiting&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;            Assert.AreEqual(2, _duelLogic.Winner); // AI wins&#10;            Assert.AreEqual(&quot;FALSE START !&quot;, result.StateText);&#10;        }&#10;&#10;        [Test]&#10;        public void WaitingUntilSignal_ShouldTransitionToSignalState()&#10;        {&#10;            // Arrange&#10;            float currentTime = 0f;&#10;            _duelLogic.UpdateState(currentTime, true); // Transition to Waiting&#10;            float signalTime = _duelLogic.SignalAt;&#10;            &#10;            // Act&#10;            var result = _duelLogic.UpdateState(signalTime, false);&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Signal, _duelLogic.State);&#10;            Assert.AreEqual(&quot;GO !&quot;, result.StateText);&#10;            Assert.AreEqual(&quot;Press Now !&quot;, result.HintText);&#10;        }&#10;&#10;        [Test]&#10;        public void PressingAfterSignal_ShouldCalculateReactionTime()&#10;        {&#10;            // Arrange&#10;            float currentTime = 0f;&#10;            _duelLogic.UpdateState(currentTime, true); // Transition to Waiting&#10;            float signalTime = _duelLogic.SignalAt;&#10;            _duelLogic.UpdateState(signalTime, false); // Transition to Signal&#10;            &#10;            // Act&#10;            float reactionTime = signalTime + 0.15f; // 150ms reaction&#10;            var result = _duelLogic.UpdateState(reactionTime, true);&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;            Assert.AreEqual(1, _duelLogic.Winner); // Player wins&#10;            Assert.AreEqual(&quot;CALCULATING...&quot;, result.StateText);&#10;            Assert.AreEqual(&quot;150 ms&quot;, result.MsText);&#10;        }&#10;&#10;        [Test]&#10;        public void ResolveState_ShouldEventuallyTransitionToResults()&#10;        {&#10;            // Arrange&#10;            float currentTime = 0f;&#10;            _duelLogic.UpdateState(currentTime, true); // Ready -&gt; Waiting&#10;            float signalTime = _duelLogic.SignalAt;&#10;            _duelLogic.UpdateState(signalTime, false); // Waiting -&gt; Signal&#10;            _duelLogic.UpdateState(signalTime + 0.1f, true); // Signal -&gt; Resolve&#10;            &#10;            // Act - Wait for resolve timer&#10;            var result = _duelLogic.UpdateState(signalTime + 2f, false);&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Results, _duelLogic.State);&#10;            Assert.AreEqual(&quot;PLAYER WINS !&quot;, result.StateText);&#10;            Assert.AreEqual(&quot;Congratulations!&quot;, result.HintText);&#10;        }&#10;&#10;        [Test]&#10;        public void ResultsState_ShouldEventuallyResetToReady()&#10;        {&#10;            // Arrange - Get to Results state&#10;            float currentTime = 0f;&#10;            _duelLogic.UpdateState(currentTime, true); // Ready -&gt; Waiting&#10;            float signalTime = _duelLogic.SignalAt;&#10;            _duelLogic.UpdateState(signalTime, false); // Waiting -&gt; Signal&#10;            _duelLogic.UpdateState(signalTime + 0.1f, true); // Signal -&gt; Resolve&#10;            _duelLogic.UpdateState(signalTime + 2f, false); // Resolve -&gt; Results&#10;            &#10;            // Act - Wait for results timer&#10;            var result = _duelLogic.UpdateState(signalTime + 5f, false);&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;            Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;            Assert.AreEqual(&quot;Press any key when ready&quot;, result.HintText);&#10;            Assert.AreEqual(&quot;&quot;, result.MsText);&#10;        }&#10;&#10;        [Test]&#10;        public void StartRound_ShouldResetAllState()&#10;        {&#10;            // Arrange - Get to some advanced state&#10;            _duelLogic.UpdateState(0f, true);&#10;            &#10;            // Act&#10;            _duelLogic.StartRound();&#10;            &#10;            // Assert&#10;            Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;            Assert.AreEqual(0, _duelLogic.Winner);&#10;            Assert.IsFalse(_duelLogic.WinnerLocked);&#10;            Assert.AreEqual(0f, _duelLogic.SignalAt);&#10;            Assert.AreEqual(0f, _duelLogic.ReactedAt);&#10;        }&#10;&#10;        [Test]&#10;        public void ConfigurationProperties_ShouldAffectBehavior()&#10;        {&#10;            // Arrange&#10;            _duelLogic.WaitRange = new Vector2(1f, 1.1f); // Very short wait&#10;            _duelLogic.ReactRange = new Vector2(50f, 60f); // Fast AI reaction&#10;            &#10;            // Act&#10;            _duelLogic.UpdateState(0f, true); // Start waiting&#10;            float signalTime = _duelLogic.SignalAt;&#10;            &#10;            // Assert&#10;            Assert.GreaterOrEqual(signalTime, 1f);&#10;            Assert.LessOrEqual(signalTime, 1.1f);&#10;        }&#10;&#10;        [Test]&#10;        public void WinnerLocking_ShouldPreventStateChanges()&#10;        {&#10;            // Arrange - Get to resolve state&#10;            float currentTime = 0f;&#10;            _duelLogic.UpdateState(currentTime, true);&#10;            float signalTime = _duelLogic.SignalAt;&#10;            _duelLogic.UpdateState(signalTime, false);&#10;            _duelLogic.UpdateState(signalTime + 0.1f, true);&#10;            &#10;            // Act - Multiple updates in resolve state&#10;            _duelLogic.UpdateState(signalTime + 0.5f, false);&#10;            int firstWinner = _duelLogic.Winner;&#10;            _duelLogic.UpdateState(signalTime + 0.6f, false);&#10;            int secondWinner = _duelLogic.Winner;&#10;            &#10;            // Assert&#10;            Assert.IsTrue(_duelLogic.WinnerLocked);&#10;            Assert.AreEqual(firstWinner, secondWinner);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Tests/GameManagerIntegrationTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Tests/GameManagerIntegrationTests.cs" />
              <option name="originalContent" value="using NUnit.Framework;&#10;using UnityEngine;&#10;using UnityEngine.TestTools;&#10;using System.Collections;&#10;&#10;[TestFixture]&#10;public class GameManagerIntegrationTests&#10;{&#10;    private DuelLogic _duelLogic;&#10;&#10;    [SetUp]&#10;    public void SetUp()&#10;    {&#10;        // Utiliser directement DuelLogic pour des tests plus simples et fiables&#10;        _duelLogic = new DuelLogic(12345); // Seed fixe pour la reproductibilité&#10;        _duelLogic.WaitRange = new Vector2(0.1f, 0.2f); // Temps très courts pour les tests&#10;        _duelLogic.ReactRange = new Vector2(50f, 100f);&#10;        _duelLogic.AiFalseStartChance = 0f; // Pas de faux départ AI pour simplifier les tests&#10;    }&#10;&#10;    [Test]&#10;    public void GameManager_SimulatedGameFlow_ShouldWork()&#10;    {&#10;        float currentTime = 0f;&#10;&#10;        // État initial&#10;        var result = _duelLogic.UpdateState(currentTime, false);&#10;        Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;        Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;&#10;        // Joueur démarre le duel&#10;        result = _duelLogic.UpdateState(currentTime, true);&#10;        Assert.AreEqual(DuelState.Waiting, _duelLogic.State);&#10;        Assert.AreEqual(&quot;READY ?&quot;, result.StateText);&#10;&#10;        // Attendre le signal&#10;        currentTime = _duelLogic.SignalAt;&#10;        result = _duelLogic.UpdateState(currentTime, false);&#10;        Assert.AreEqual(DuelState.Signal, _duelLogic.State);&#10;        Assert.AreEqual(&quot;GO !&quot;, result.StateText);&#10;&#10;        // Joueur réagit&#10;        currentTime += 0.15f; // 150ms de réaction&#10;        result = _duelLogic.UpdateState(currentTime, true);&#10;        Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;        Assert.AreEqual(&quot;CALCULATING...&quot;, result.StateText);&#10;        Assert.AreEqual(&quot;150 ms&quot;, result.MsText);&#10;&#10;        // Attendre la résolution&#10;        currentTime += 1.5f;&#10;        result = _duelLogic.UpdateState(currentTime, false);&#10;        Assert.AreEqual(DuelState.Results, _duelLogic.State);&#10;        Assert.AreEqual(&quot;PLAYER WINS !&quot;, result.StateText);&#10;&#10;        // Retour au début&#10;        currentTime += 3f;&#10;        result = _duelLogic.UpdateState(currentTime, false);&#10;        Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;        Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;    }&#10;&#10;    [Test]&#10;    public void GameManager_FalseStartScenario_ShouldWork()&#10;    {&#10;        float currentTime = 0f;&#10;&#10;        // Démarrer le duel&#10;        _duelLogic.UpdateState(currentTime, true);&#10;        Assert.AreEqual(DuelState.Waiting, _duelLogic.State);&#10;&#10;        // Faux départ du joueur&#10;        currentTime += 0.05f; // Avant le signal&#10;        var result = _duelLogic.UpdateState(currentTime, true);&#10;&#10;        Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;        Assert.AreEqual(2, _duelLogic.Winner); // AI gagne&#10;        Assert.AreEqual(&quot;FALSE START !&quot;, result.StateText);&#10;    }&#10;&#10;    [Test]&#10;    public void GameManager_MultipleRounds_ShouldWork()&#10;    {&#10;        // Test de plusieurs rounds consécutifs&#10;        for (int round = 0; round &lt; 3; round++)&#10;        {&#10;            float currentTime = round * 10f; // Décalage temporel pour chaque round&#10;&#10;            // Round complet&#10;            _duelLogic.UpdateState(currentTime, true); // Start&#10;            currentTime = _duelLogic.SignalAt;&#10;            _duelLogic.UpdateState(currentTime, false); // Signal&#10;            currentTime += 0.1f;&#10;            _duelLogic.UpdateState(currentTime, true); // React&#10;            currentTime += 2f;&#10;            _duelLogic.UpdateState(currentTime, false); // Results&#10;            currentTime += 3f;&#10;            var result = _duelLogic.UpdateState(currentTime, false); // Reset&#10;&#10;            Assert.AreEqual(DuelState.Ready, _duelLogic.State, $&quot;Round {round + 1} should end in Ready state&quot;);&#10;            Assert.AreEqual(&quot;GET READY&quot;, result.StateText, $&quot;Round {round + 1} should show GET READY&quot;);&#10;        }&#10;    }&#10;}&#10;&#10;// Version simplifiée pour les tests du composant Unity (optionnel)&#10;public class MockDuelInputBehaviour : MonoBehaviour&#10;{&#10;    private bool _pressedThisFrame;&#10;&#10;    public bool ConsumePressed()&#10;    {&#10;        if (!_pressedThisFrame) return false;&#10;        _pressedThisFrame = false;&#10;        return true;&#10;    }&#10;&#10;    public void SimulatePress()&#10;    {&#10;        _pressedThisFrame = true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using NUnit.Framework;&#10;using UnityEngine;&#10;using Assert = NUnit.Framework.Assert;&#10;&#10;namespace Tests&#10;{&#10;    [TestFixture]&#10;    public class GameManagerIntegrationTests&#10;    {&#10;        private DuelLogic _duelLogic;&#10;&#10;        [SetUp]&#10;        public void SetUp()&#10;        {&#10;            // Utiliser directement DuelLogic pour des tests plus simples et fiables&#10;            _duelLogic = new DuelLogic(12345); // Seed fixe pour la reproductibilité&#10;            _duelLogic.WaitRange = new Vector2(0.1f, 0.2f); // Temps très courts pour les tests&#10;            _duelLogic.ReactRange = new Vector2(50f, 100f);&#10;            _duelLogic.AiFalseStartChance = 0f; // Pas de faux départ AI pour simplifier les tests&#10;        }&#10;&#10;        [Test]&#10;        public void GameManager_SimulatedGameFlow_ShouldWork()&#10;        {&#10;            float currentTime = 0f;&#10;&#10;            // État initial&#10;            var result = _duelLogic.UpdateState(currentTime, false);&#10;            Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;            Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;&#10;            // Joueur démarre le duel&#10;            result = _duelLogic.UpdateState(currentTime, true);&#10;            Assert.AreEqual(DuelState.Waiting, _duelLogic.State);&#10;            Assert.AreEqual(&quot;READY ?&quot;, result.StateText);&#10;&#10;            // Attendre le signal&#10;            currentTime = _duelLogic.SignalAt;&#10;            result = _duelLogic.UpdateState(currentTime, false);&#10;            Assert.AreEqual(DuelState.Signal, _duelLogic.State);&#10;            Assert.AreEqual(&quot;GO !&quot;, result.StateText);&#10;&#10;            // Joueur réagit&#10;            currentTime += 0.15f; // 150ms de réaction&#10;            result = _duelLogic.UpdateState(currentTime, true);&#10;            Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;            Assert.AreEqual(&quot;CALCULATING...&quot;, result.StateText);&#10;            Assert.AreEqual(&quot;150 ms&quot;, result.MsText);&#10;&#10;            // Attendre la résolution&#10;            currentTime += 1.5f;&#10;            result = _duelLogic.UpdateState(currentTime, false);&#10;            Assert.AreEqual(DuelState.Results, _duelLogic.State);&#10;            Assert.AreEqual(&quot;PLAYER WINS !&quot;, result.StateText);&#10;&#10;            // Retour au début&#10;            currentTime += 3f;&#10;            result = _duelLogic.UpdateState(currentTime, false);&#10;            Assert.AreEqual(DuelState.Ready, _duelLogic.State);&#10;            Assert.AreEqual(&quot;GET READY&quot;, result.StateText);&#10;        }&#10;&#10;        [Test]&#10;        public void GameManager_FalseStartScenario_ShouldWork()&#10;        {&#10;            float currentTime = 0f;&#10;&#10;            // Démarrer le duel&#10;            _duelLogic.UpdateState(currentTime, true);&#10;            Assert.AreEqual(DuelState.Waiting, _duelLogic.State);&#10;&#10;            // Faux départ du joueur&#10;            currentTime += 0.05f; // Avant le signal&#10;            var result = _duelLogic.UpdateState(currentTime, true);&#10;&#10;            Assert.AreEqual(DuelState.Resolve, _duelLogic.State);&#10;            Assert.AreEqual(2, _duelLogic.Winner); // AI gagne&#10;            Assert.AreEqual(&quot;FALSE START !&quot;, result.StateText);&#10;        }&#10;&#10;        [Test]&#10;        public void GameManager_MultipleRounds_ShouldWork()&#10;        {&#10;            // Test de plusieurs rounds consécutifs&#10;            for (int round = 0; round &lt; 3; round++)&#10;            {&#10;                float currentTime = round * 10f; // Décalage temporel pour chaque round&#10;&#10;                // Round complet&#10;                _duelLogic.UpdateState(currentTime, true); // Start&#10;                currentTime = _duelLogic.SignalAt;&#10;                _duelLogic.UpdateState(currentTime, false); // Signal&#10;                currentTime += 0.1f;&#10;                _duelLogic.UpdateState(currentTime, true); // React&#10;                currentTime += 2f;&#10;                _duelLogic.UpdateState(currentTime, false); // Results&#10;                currentTime += 3f;&#10;                var result = _duelLogic.UpdateState(currentTime, false); // Reset&#10;&#10;                Assert.AreEqual(DuelState.Ready, _duelLogic.State, $&quot;Round {round + 1} should end in Ready state&quot;);&#10;                Assert.AreEqual(&quot;GET READY&quot;, result.StateText, $&quot;Round {round + 1} should show GET READY&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Version simplifiée pour les tests du composant Unity (optionnel)&#10;    public class MockDuelInputBehaviour : MonoBehaviour&#10;    {&#10;        private bool _pressedThisFrame;&#10;&#10;        public bool ConsumePressed()&#10;        {&#10;            if (!_pressedThisFrame) return false;&#10;            _pressedThisFrame = false;&#10;            return true;&#10;        }&#10;&#10;        public void SimulatePress()&#10;        {&#10;            _pressedThisFrame = true;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>